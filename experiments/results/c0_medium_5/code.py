# Autogenerated strategy combining MACD crossover entries with ATR-based trailing stops
# compute_indicators and order_func are exported for use with vectorbt.Portfolio.from_order_func

from typing import Any, Dict, Optional, Tuple

import numpy as np
import pandas as pd


class _Order:
    """Minimal order-like object with flexible attributes for the simulator.

    The simulator inspects attributes like `price`, `size`, and `_code`. We provide those
    and return NaN for any other attribute accessed to avoid AttributeError.
    This is a fallback; the primary approach is to return a tuple matching the
    simulator's expected namedtuple layout when possible.
    """

    __slots__ = ("size", "price", "_code")

    def __init__(self, size: float, price: float, code: int = 1) -> None:
        self.size = float(size)
        self.price = float(price)
        self._code = int(code)

    def __getattr__(self, name: str) -> float:  # pragma: no cover - defensive
        return float("nan")


def compute_indicators(
    ohlcv: pd.DataFrame,
    macd_fast: int = 12,
    macd_slow: int = 26,
    macd_signal: int = 9,
    sma_period: int = 50,
    atr_period: int = 14,
) -> Dict[str, np.ndarray]:
    """
    Compute indicators required by the strategy.

    Returns a dict containing numpy arrays for the following keys:
    - close: close prices
    - high: high prices
    - macd: MACD line (fast EMA - slow EMA)
    - signal: MACD signal line
    - atr: Average True Range (ATR)
    - sma: Simple Moving Average (trend filter)

    All returned arrays have the same length as the input ohlcv DataFrame.
    NaN handling: initial warmup values are left as NaN where appropriate.
    """
    # Validate input
    if not isinstance(ohlcv, pd.DataFrame):
        raise TypeError("ohlcv must be a pandas DataFrame")

    # Ensure required columns exist
    for col in ("close", "high", "low"):
        if col not in ohlcv.columns:
            raise KeyError(f"ohlcv must contain '{col}' column")

    close_s = ohlcv["close"].astype(float)
    high_s = ohlcv["high"].astype(float)
    low_s = ohlcv["low"].astype(float)

    # MACD: EMA fast - EMA slow, signal is EMA of MACD
    ema_fast = close_s.ewm(span=macd_fast, adjust=False).mean()
    ema_slow = close_s.ewm(span=macd_slow, adjust=False).mean()
    macd_line = ema_fast - ema_slow
    signal_line = macd_line.ewm(span=macd_signal, adjust=False).mean()

    # SMA trend filter
    sma = close_s.rolling(window=sma_period, min_periods=1).mean()

    # ATR: True Range then rolling (simple rolling mean)
    prev_close = close_s.shift(1)
    tr1 = high_s - low_s
    tr2 = (high_s - prev_close).abs()
    tr3 = (low_s - prev_close).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.rolling(window=atr_period, min_periods=1).mean()

    # Convert to numpy arrays
    return {
        "close": close_s.values.astype(float),
        "high": high_s.values.astype(float),
        "macd": macd_line.values.astype(float),
        "signal": signal_line.values.astype(float),
        "atr": atr.values.astype(float),
        "sma": sma.values.astype(float),
    }


def _extract_index(obj: Any) -> int:
    """Robustly extract integer time index from the first argument passed to order_func.

    Vectorbt may pass an OrderContext-like object as the first parameter. This helper
    tries several common attribute names and falls back to treating the object as an int.
    """
    # Direct int-like
    if isinstance(obj, (int, np.integer)):
        return int(obj)
    # Common OrderContext attribute names
    for attr in ("i", "idx", "index", "index_i", "pos", "t"):
        if hasattr(obj, attr):
            try:
                return int(getattr(obj, attr))
            except Exception:
                continue
    # Maybe it's dict-like
    try:
        if isinstance(obj, dict) and "i" in obj:
            return int(obj["i"])
    except Exception:
        pass
    # As a last resort, try to convert to int directly
    try:
        return int(obj)
    except Exception as e:
        raise TypeError(f"Cannot extract integer index from object of type {type(obj)}: {e}")


def _val_at(x: Any, idx: int) -> float:
    """Return the value at idx if x is subscriptable, otherwise attempt to convert x to float.

    On failure returns NaN.
    """
    # If x is a numpy array, pandas Series or list-like, try indexing
    try:
        if isinstance(x, (np.ndarray, list, tuple, pd.Series)):
            return float(x[idx])
        # Some objects (e.g., numpy scalar) are not subscriptable but convertible
        return float(x)
    except Exception:
        # Try to access as mapping or indexable
        try:
            return float(x[idx])
        except Exception:
            try:
                return float(x)
            except Exception:
                return float("nan")


def _to_float(x: Any) -> float:
    """Convert common numeric types to Python float safely; on failure return nan."""
    try:
        return float(x)
    except Exception:
        return float("nan")


def _build_order_tuple_for_fields(fields: Tuple[str, ...], size: float, price: float) -> Tuple[float, ...]:
    """
    Build a tuple of floats for the given order fields ordering. We place `size` and `price`
    into matching named fields when possible, otherwise we fill with NaN.
    """
    out = []
    for f in fields:
        # common aliases
        fname = f.lower()
        if fname in ("size", "amount", "qty", "quantity"):
            out.append(float(size))
        elif fname in ("price", "p", "order_price"):
            out.append(float(price))
        elif fname in ("code", "_code"):
            out.append(1.0 if float(price) != float("inf") and float(size) != 0.0 else 0.0)
        elif fname in ("size_type", "sizetype", "sizetype_code"):
            # default to 0 which corresponds to 'size' interpretation (units)
            out.append(0.0)
        elif fname in ("direction", "dir", "side"):
            # 1 for buy, -1 for sell, 0 for no order
            v = 0.0
            try:
                if float(size) > 0:
                    v = 1.0
                elif float(size) < 0:
                    v = -1.0
            except Exception:
                v = 0.0
            out.append(v)
        else:
            # default placeholder numeric
            out.append(float("nan"))
    return tuple(out)


def order_func(
    order_ctx_or_t: Any,
    price: Any,
    close: Any,
    high: Any,
    macd: Any,
    signal: Any,
    atr: Any,
    sma: Any,
    trailing_mult: float = 2.0,
) -> Any:
    """
    Order function for vectorbt.Portfolio.from_order_func (use_numba=False).

    This function is called sequentially for each bar. It keeps state on the function
    object to remember whether we are currently in a long position, the entry index,
    the highest price seen since entry (for the ATR-based trailing stop), and the
    previous MACD/Signal values to detect crossovers when only scalars are passed.

    The function attempts to detect the simulator's expected Order namedtuple layout at
    runtime and return an instance of that namedtuple. If detection fails, it falls back
    to returning a lightweight _Order object.
    """
    # Initialize persistent state on the function
    if not hasattr(order_func, "_state"):
        # _state holds: pos (0 or 1), entry_idx (int), entry_high (float), last_macd, last_signal
        order_func._state = {
            "pos": 0,
            "entry_idx": -1,
            "entry_high": -np.inf,
            "last_macd": float("nan"),
            "last_signal": float("nan"),
        }
        # Cache for detected order fields and class
        order_func._order_fields = None
        order_func._OrderClass = None

    state = order_func._state

    # Extract the integer index
    try:
        idx = _extract_index(order_ctx_or_t)
    except Exception:
        # Fallback: try if price argument is actually the context
        try:
            idx = _extract_index(price)
        except Exception as e:
            raise

    # Validate index bounds
    try:
        n = len(close) if hasattr(close, "__len__") else None
    except Exception:
        n = None
    if n is not None and (idx < 0 or idx >= n):
        # Build fallback no-order return
        if order_func._order_fields is not None and order_func._OrderClass is not None:
            vals = _build_order_tuple_for_fields(order_func._order_fields, 0.0, float("inf"))
            try:
                return order_func._OrderClass(*vals)
            except Exception:
                return vals
        if order_func._order_fields is not None:
            return _build_order_tuple_for_fields(order_func._order_fields, 0.0, float("inf"))
        return _Order(0.0, float("inf"), code=0)

    # Obtain scalar values for the current bar from possibly array or scalar inputs
    macd_t = _val_at(macd, idx)
    signal_t = _val_at(signal, idx)
    close_t = _val_at(close, idx)
    high_t = _val_at(high, idx)
    sma_t = _val_at(sma, idx)
    atr_t = _val_at(atr, idx)

    # Price argument may be scalar or array-like; prefer a direct float conversion
    price_f = _val_at(price, idx) if (hasattr(price, "__len__") and not isinstance(price, (float, int, np.floating, np.integer))) else _to_float(price)
    if np.isnan(price_f):
        price_f = close_t

    macd_prev = state.get("last_macd", float("nan"))
    signal_prev = state.get("last_signal", float("nan"))

    pos = int(state["pos"])  # 0 = flat, 1 = long

    # Helper: check MACD cross above/below with robust NaN handling
    def macd_cross_above(prev_m: float, prev_s: float, cur_m: float, cur_s: float) -> bool:
        if np.isnan(prev_m) or np.isnan(prev_s) or np.isnan(cur_m) or np.isnan(cur_s):
            return False
        return (prev_m <= prev_s) and (cur_m > cur_s)

    def macd_cross_below(prev_m: float, prev_s: float, cur_m: float, cur_s: float) -> bool:
        if np.isnan(prev_m) or np.isnan(prev_s) or np.isnan(cur_m) or np.isnan(cur_s):
            return False
        return (prev_m >= prev_s) and (cur_m < cur_s)

    # Update highest price since entry if currently long
    if pos == 1:
        prev_high = state.get("entry_high", -np.inf)
        if prev_high == -np.inf:
            prev_high = high_t if not np.isnan(high_t) else close_t
        entry_high = max(prev_high, high_t if not np.isnan(high_t) else prev_high)
        state["entry_high"] = entry_high
    else:
        # Ensure entry_high reset when flat
        state["entry_high"] = -np.inf

    # Detect or cache order fields layout once
    if order_func._order_fields is None:
        try:
            import vectorbt as vbt
            # Try common locations for Order namedtuple
            OrderClass = None
            if hasattr(vbt, "portfolio"):
                if hasattr(vbt.portfolio, "nb") and hasattr(vbt.portfolio.nb, "Order"):
                    OrderClass = vbt.portfolio.nb.Order
                elif hasattr(vbt.portfolio, "base") and hasattr(vbt.portfolio.base, "Order"):
                    OrderClass = vbt.portfolio.base.Order
            if OrderClass is not None and hasattr(OrderClass, "_fields"):
                order_func._order_fields = tuple(OrderClass._fields)
                order_func._OrderClass = OrderClass
        except Exception:
            order_func._order_fields = None
            order_func._OrderClass = None

    # Evaluate entry: MACD cross above and price above SMA and currently flat
    if pos == 0:
        if macd_cross_above(macd_prev, signal_prev, macd_t, signal_t) and (not np.isnan(sma_t)):
            # Price must be above SMA
            if (not np.isnan(close_t)) and (close_t > sma_t):
                # Enter long: buy 1 unit
                size = 1.0
                state["pos"] = 1
                state["entry_idx"] = idx
                state["entry_high"] = high_t if not np.isnan(high_t) else close_t
                # Update last values for next iteration
                state["last_macd"] = macd_t
                state["last_signal"] = signal_t
                # Return order in detected format if possible
                if order_func._order_fields is not None and order_func._OrderClass is not None:
                    vals = _build_order_tuple_for_fields(order_func._order_fields, size, price_f)
                    try:
                        return order_func._OrderClass(*vals)
                    except Exception:
                        return vals
                return _Order(float(size), float(price_f), code=1)

    # Evaluate exit: only if currently long
    if pos == 1:
        entry_high = state.get("entry_high", high_t if not np.isnan(high_t) else close_t)
        trailing_stop = None
        if not np.isnan(atr_t):
            trailing_stop = entry_high - (trailing_mult * atr_t)

        macd_exit = macd_cross_below(macd_prev, signal_prev, macd_t, signal_t)
        atr_exit = False
        if (trailing_stop is not None) and (not np.isnan(close_t)):
            atr_exit = close_t < trailing_stop

        if macd_exit or atr_exit:
            # Exit fully: sell 1 unit
            size = -1.0
            state["pos"] = 0
            state["entry_idx"] = -1
            state["entry_high"] = -np.inf
            # Update last values for next iteration
            state["last_macd"] = macd_t
            state["last_signal"] = signal_t
            if order_func._order_fields is not None and order_func._OrderClass is not None:
                vals = _build_order_tuple_for_fields(order_func._order_fields, size, price_f)
                try:
                    return order_func._OrderClass(*vals)
                except Exception:
                    return vals
            return _Order(float(size), float(price_f), code=1)

    # Update last MACD/Signal even if no order so that cross detection works on next call
    state["last_macd"] = macd_t
    state["last_signal"] = signal_t

    # No order -> return sentinel that simulator treats as no order
    if order_func._order_fields is not None and order_func._OrderClass is not None:
        vals = _build_order_tuple_for_fields(order_func._order_fields, 0.0, float("inf"))
        try:
            return order_func._OrderClass(*vals)
        except Exception:
            return vals
    if order_func._order_fields is not None:
        return _build_order_tuple_for_fields(order_func._order_fields, 0.0, float("inf"))
    return _Order(0.0, float("inf"), code=0)
