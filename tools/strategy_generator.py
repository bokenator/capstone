"""Codex-powered strategy agent for iterative code generation and fixing.

This module implements an agentic approach where Codex generates strategy code,
sees execution errors, and iteratively fixes them until the code works.
"""

from __future__ import annotations

import ast
import os
import re
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

from openai import OpenAI


SYSTEM_PROMPT = """You are an expert quantitative trading strategy developer using vectorbt. Your task is to generate Python code that implements trading strategies.

CRITICAL: Your strategy must generate MULTIPLE entry and exit signals throughout the data period. A strategy that only generates 1 signal is useless - it should generate signals whenever the trading conditions are met.

STRICT REQUIREMENTS - Your code MUST follow this exact pattern:

```python
def generate_signals(prices: pd.DataFrame) -> tuple[pd.Series, pd.Series]:
    \"\"\"
    Generate entry and exit signals for a trading strategy.

    Args:
        prices: DataFrame with columns 'open', 'high', 'low', 'close', 'volume' (lowercase)

    Returns:
        Tuple of (entries, exits) as boolean pd.Series with same index as prices
    \"\"\"
    close = prices['close']

    # Calculate indicators
    # Example: rsi = vbt.RSI.run(close, window=14).rsi

    # Generate entry signals (True when condition is met)
    # Example: entries = rsi < 30  # Buy when RSI is oversold

    # Generate exit signals (True when condition is met)
    # Example: exits = rsi > 70  # Sell when RSI is overbought

    # IMPORTANT: Ensure entries and exits are boolean Series
    entries = entries.fillna(False).astype(bool)
    exits = exits.fillna(False).astype(bool)

    return entries, exits
```

EXAMPLE - RSI Strategy:
```python
def generate_signals(prices: pd.DataFrame) -> tuple[pd.Series, pd.Series]:
    close = prices['close']
    rsi = vbt.RSI.run(close, window=14).rsi
    entries = (rsi < 30).fillna(False).astype(bool)
    exits = (rsi > 70).fillna(False).astype(bool)
    return entries, exits
```

EXAMPLE - Moving Average Crossover:
```python
def generate_signals(prices: pd.DataFrame) -> tuple[pd.Series, pd.Series]:
    close = prices['close']
    fast_ma = vbt.MA.run(close, window=10).ma
    slow_ma = vbt.MA.run(close, window=30).ma
    entries = (fast_ma > slow_ma).fillna(False).astype(bool)
    exits = (fast_ma < slow_ma).fillna(False).astype(bool)
    return entries, exits
```

RULES:
1. Function MUST be named `generate_signals`
2. Function MUST accept `prices: pd.DataFrame` as only argument
3. Function MUST return `tuple[pd.Series, pd.Series]` as (entries, exits)
4. Both entries and exits MUST be boolean Series with same index as prices
5. Signals should be generated by COMPARING indicator values (e.g., rsi < 30, not rsi.idxmin())
6. Use `.fillna(False).astype(bool)` on signals to handle NaN values
7. Available pre-imported modules: pandas (pd), numpy (np), vectorbt (vbt)
8. DO NOT import any modules - they are pre-imported
9. DO NOT use file I/O, network calls, or system commands

AVAILABLE VECTORBT INDICATORS:
- vbt.MA.run(close, window) → .ma for values
- vbt.RSI.run(close, window) → .rsi for values
- vbt.BBANDS.run(close, window, alpha) → .upper, .middle, .lower
- vbt.MACD.run(close, fast_window, slow_window, signal_window) → .macd, .signal
- vbt.ATR.run(high, low, close, window) → .atr
- vbt.STOCH.run(high, low, close, k_window, d_window) → .percent_k, .percent_d

OUTPUT FORMAT:
- Output ONLY the Python function code
- No markdown code blocks, no explanations before or after
- Start directly with `def generate_signals(`

MODIFYING EXISTING STRATEGIES:
When asked to modify an existing strategy, preserve the overall structure and only change what's requested.
- Keep working parts intact
- Only modify the specific parameters, indicators, or logic mentioned
- Ensure the modified code still follows all the rules above"""


DANGEROUS_PATTERNS = [
    r'\bimport\s+',
    r'\bfrom\s+\w+\s+import\b',
    r'\bopen\s*\(',
    r'\bexec\s*\(',
    r'\beval\s*\(',
    r'\bcompile\s*\(',
    r'\b__import__\s*\(',
    r'\bos\.',
    r'\bsys\.',
    r'\bsubprocess\.',
    r'\bshutil\.',
    r'\brequests\.',
    r'\burllib\.',
    r'\bsocket\.',
]


@dataclass
class ExecutionResult:
    """Result from executing generated code."""
    success: bool
    error: Optional[str] = None
    error_type: Optional[str] = None
    traceback: Optional[str] = None
    result: Optional[Dict[str, Any]] = None


@dataclass
class CodexSession:
    """Maintains conversation context for iterative code generation."""
    messages: List[Dict[str, str]] = field(default_factory=list)
    generated_code: str = ""
    attempts: int = 0
    max_attempts: int = 5


class CodexAgent:
    """Agentic code generator using Codex that can iteratively fix errors."""

    def __init__(
        self,
        api_key: Optional[str] = None,
        model: str = "gpt-5.1",
        max_attempts: int = 5,
    ):
        """Initialize the Codex agent.

        Args:
            api_key: OpenAI API key. If None, reads from OPENAI_API_KEY env var.
            model: Model to use. Default is gpt-5.1 for code generation tasks.
            max_attempts: Maximum number of generate-execute-fix cycles.
        """
        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        if not self.api_key:
            raise RuntimeError("Missing OPENAI_API_KEY in environment")

        self.client = OpenAI(api_key=self.api_key)
        self.model = model
        self.max_attempts = max_attempts

    def create_session(
        self,
        strategy_prompt: str,
        base_code: Optional[str] = None,
    ) -> CodexSession:
        """Create a new Codex session for a strategy request.

        Args:
            strategy_prompt: Natural language description of the trading strategy,
                or modifications to make if base_code is provided.
            base_code: Optional existing strategy code to modify.

        Returns:
            CodexSession with initialized conversation.
        """
        session = CodexSession(max_attempts=self.max_attempts)

        if base_code:
            # Modification mode: refine existing strategy
            user_message = f"""Modify this existing trading strategy:

```python
{base_code}
```

Requested changes: {strategy_prompt}

Output ONLY the modified Python function code."""
        else:
            # Creation mode: generate new strategy
            user_message = f"Create a trading strategy: {strategy_prompt}"

        session.messages = [
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": user_message},
        ]
        return session

    def generate(self, session: CodexSession) -> str:
        """Generate or regenerate code based on current session state.

        Args:
            session: The current Codex session with conversation history.

        Returns:
            Generated Python code.
        """
        session.attempts += 1

        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=session.messages,
                temperature=0.2,
                max_completion_tokens=2000,
            )
        except Exception as e:
            print(f"OpenAI API error: {type(e).__name__}: {e}")
            raise

        raw_code = response.choices[0].message.content or ""
        code = self._extract_code(raw_code)
        session.generated_code = code

        # Add assistant response to conversation history
        session.messages.append({
            "role": "assistant",
            "content": raw_code,
        })

        return code

    def feed_error(self, session: CodexSession, execution_result: ExecutionResult) -> None:
        """Feed an execution error back to the agent for fixing.

        Args:
            session: The current Codex session.
            execution_result: The result from executing the generated code.
        """
        error_message = f"""The code you generated failed during execution.

Error Type: {execution_result.error_type}
Error Message: {execution_result.error}

{f"Traceback:{chr(10)}{execution_result.traceback}" if execution_result.traceback else ""}

Please fix the code. Remember:
1. Function must be named `generate_signals`
2. Must return tuple of (entries, exits) as boolean pd.Series
3. Use .fillna(False).astype(bool) on signals
4. Only use pd, np, vbt - no imports

Output ONLY the corrected Python function code, no explanations."""

        session.messages.append({
            "role": "user",
            "content": error_message,
        })

    def feed_validation_error(self, session: CodexSession, error: str) -> None:
        """Feed a validation error back to the agent.

        Args:
            session: The current Codex session.
            error: The validation error message.
        """
        error_message = f"""The code you generated failed validation:

{error}

Please fix the code following the exact requirements:
1. Function must be named `generate_signals`
2. Must accept `prices: pd.DataFrame` as only argument
3. Must return `tuple[pd.Series, pd.Series]` as (entries, exits)
4. No imports - pd, np, vbt are pre-imported

Output ONLY the corrected Python function code, no explanations."""

        session.messages.append({
            "role": "user",
            "content": error_message,
        })

    def feed_signal_error(self, session: CodexSession, entry_count: int, exit_count: int) -> None:
        """Feed a signal count error back to the agent.

        Args:
            session: The current Codex session.
            entry_count: Number of entry signals generated.
            exit_count: Number of exit signals generated.
        """
        error_message = f"""The strategy code executed but generated too few signals:
- Entry signals: {entry_count}
- Exit signals: {exit_count}

A useful trading strategy should generate MANY signals throughout the data period (at least 5-10 entry signals).

The problem is likely that you're using a method that returns a single value (like .idxmin() or .argmax()) instead of a boolean comparison that returns a Series of True/False values.

CORRECT approach - generates multiple signals:
```python
entries = (rsi < 30).fillna(False).astype(bool)  # True for EVERY bar where RSI < 30
exits = (rsi > 70).fillna(False).astype(bool)    # True for EVERY bar where RSI > 70
```

WRONG approach - generates only 1 signal:
```python
entries = pd.Series(False, index=prices.index)
entries.iloc[rsi.idxmin()] = True  # Only 1 entry at the minimum RSI
```

Please rewrite the strategy to use boolean comparisons that generate signals whenever the condition is met.

Output ONLY the corrected Python function code, no explanations."""

        session.messages.append({
            "role": "user",
            "content": error_message,
        })

    def validate_code(self, code: str) -> tuple[bool, Optional[str]]:
        """Validate generated code for safety and correctness.

        Returns:
            Tuple of (is_valid, error_message).
        """
        if not code or not code.strip():
            return False, "Empty code generated"

        # Check for dangerous patterns
        for pattern in DANGEROUS_PATTERNS:
            if re.search(pattern, code, re.IGNORECASE):
                return False, f"Dangerous pattern detected: {pattern}"

        # Check syntax
        try:
            ast.parse(code)
        except SyntaxError as e:
            return False, f"Syntax error on line {e.lineno}: {e.msg}"

        # Check for required function
        if 'def generate_signals' not in code:
            return False, "Missing required function 'generate_signals'"

        # Check function signature (basic check)
        if 'prices' not in code:
            return False, "Function must accept 'prices' parameter"

        # Check for return statement
        if 'return' not in code:
            return False, "Function must have a return statement"

        return True, None

    def _extract_code(self, raw_response: str) -> str:
        """Extract Python code from the model response."""
        # Try to extract from markdown code block
        code_block_pattern = r'```(?:python)?\s*\n(.*?)```'
        matches = re.findall(code_block_pattern, raw_response, re.DOTALL)
        if matches:
            return matches[0].strip()

        # If no code block, look for function definition
        lines = raw_response.strip().split('\n')
        code_lines = []
        in_function = False
        indent_level = 0

        for line in lines:
            if line.strip().startswith('def generate_signals'):
                in_function = True
                indent_level = len(line) - len(line.lstrip())

            if in_function:
                # Check if we've exited the function (non-empty line with less indentation)
                if line.strip() and not line.startswith(' ' * (indent_level + 1)) and not line.strip().startswith('def'):
                    if code_lines:  # We have some code already
                        current_indent = len(line) - len(line.lstrip())
                        if current_indent <= indent_level and not line.strip().startswith('#'):
                            break
                code_lines.append(line)

        if code_lines:
            return '\n'.join(code_lines)

        return raw_response.strip()


def get_codex_agent(
    api_key: Optional[str] = None,
    model: str = "gpt-5.1",
    max_attempts: int = 5,
) -> CodexAgent:
    """Factory function to create a CodexAgent instance."""
    return CodexAgent(api_key=api_key, model=model, max_attempts=max_attempts)
